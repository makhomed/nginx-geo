#!/usr/bin/python3 -u

__author__ = "Hennadii Makhomed"
__contact__ = "https://github.com/makhomed/nginx-geo"
__license__ = "GNU Affero General Public License, version 3.0 or later"
__version__ = "2.0.2"

# imports {{{

try:
    import tomllib # https://docs.python.org/3/library/tomllib.html
except ModuleNotFoundError:
    try:
        import tomli as tomllib # https://pypi.org/project/tomli/
    except ModuleNotFoundError:
        import sys ; sys.exit(
            "\nTOML [ https://toml.io/ ] parser not found.\n"
            f"\nInstall it with:\n"
            f"\n    {sys.executable or 'python3'} -m pip install tomli\n"
        )

from pathlib import Path, PurePosixPath

import csv
import json
import os
import re
import requests
import secrets
import shutil
import signal
import sys
import time
import zipfile

# }}}

# variables {{{

configuration_filename = Path('/opt/nginx-geo/nginx-geo.toml')

local_database_var_dir = Path('/opt/nginx-geo/var')
local_database_zipfile = Path('/opt/nginx-geo/var/GeoLite2-Country-CSV.zip')
local_database_version = Path('/opt/nginx-geo/var/GeoLite2-Country-CSV.zip.version')

default_account_id = ''
default_license_key = ''
default_database_url = 'https://download.maxmind.com/geoip/databases/GeoLite2-Country-CSV/download?suffix=zip'
default_output_dir = '/etc/nginx/include'
default_generate_separate_ipv4_and_ipv6_configuration_files = False
default_mark_tor_exit_nodes_with_T1_country_code = True
default_nginx_pid_file = '/run/nginx.pid'
default_reload_nginx = True

account_id = None
license_key = None
database_url = None
output_dir = None
generate_separate_ipv4_and_ipv6_configuration_files = None
mark_tor_exit_nodes_with_T1_country_code = None
nginx_pid_file = None
reload_nginx = None

GEOLITE2_COUNTRY_TARGET_BASENAMES = {
    'GeoLite2-Country-Blocks-IPv4.csv',
    'GeoLite2-Country-Blocks-IPv6.csv',
    'GeoLite2-Country-Locations-en.csv',
}

blocks_ip_v4 = local_database_var_dir / 'GeoLite2-Country-Blocks-IPv4.csv'
blocks_ip_v6 = local_database_var_dir / 'GeoLite2-Country-Blocks-IPv6.csv'
locations_en = local_database_var_dir / 'GeoLite2-Country-Locations-en.csv'

blocks_ip_v4_fieldnames = 'network,geoname_id,registered_country_geoname_id,represented_country_geoname_id,is_anonymous_proxy,is_satellite_provider,is_anycast'
blocks_ip_v6_fieldnames = 'network,geoname_id,registered_country_geoname_id,represented_country_geoname_id,is_anonymous_proxy,is_satellite_provider,is_anycast'
locations_en_fieldnames = 'geoname_id,locale_code,continent_code,continent_name,country_iso_code,country_name,is_in_european_union'

TOR_EXIT_NODES_IPV4_ONLY_URL = "https://check.torproject.org/exit-addresses"
TOR_EXIT_NODES_IPV4_IPV6_URL = "https://onionoo.torproject.org/details"

tor_exit_nodes_ipv4_only_filename = local_database_var_dir / 'tor-exit-nodes-ipv4-only.txt'
tor_exit_nodes_ipv4_ipv6_filename = local_database_var_dir / 'tor-exit-nodes-ipv4-ipv6.json'

geo_info = dict()
net_ipv4 = dict()
net_ipv6 = dict()

tor_ipv4 = list()
tor_ipv6 = list()

requests_connect_timeout = 10
requests_read_timeout = 10

# }}}

def fatal(message): # {{{
    print(file=sys.stderr, flush=True)
    print(message, file=sys.stderr, flush=True)
    print(file=sys.stderr, flush=True)
    sys.exit(1)
# }}}

def atomic_write_text(content, filename): # {{{
    assert isinstance(content, str)
    assert isinstance(filename, Path)
    tmp_filename = filename.with_name(filename.name + '.tmp.' + secrets.token_hex() + '.tmp')
    tmp_filename.write_text(content)
    tmp_filename.rename(filename)
# }}}

def init(): # {{{
    local_database_var_dir.mkdir(parents=True, exist_ok=True)
    if configuration_filename.is_file():
        config = tomllib.loads(configuration_filename.read_text())
    else:
        fatal(f'required configuration file {configuration_filename}')
    if 'account_id' not in config: config['account_id'] = default_account_id
    if 'license_key' not in config: config['license_key'] = default_license_key
    if 'database_url' not in config: config['database_url'] = default_database_url
    if 'output_dir' not in config: config['output_dir'] = default_output_dir
    if 'generate_separate_ipv4_and_ipv6_configuration_files' not in config: 
        config['generate_separate_ipv4_and_ipv6_configuration_files'] = default_generate_separate_ipv4_and_ipv6_configuration_files
    if 'mark_tor_exit_nodes_with_T1_country_code' not in config: 
        config['mark_tor_exit_nodes_with_T1_country_code'] = default_mark_tor_exit_nodes_with_T1_country_code
    if 'nginx_pid_file' not in config: config['nginx_pid_file'] = default_nginx_pid_file
    if 'reload_nginx' not in config: config['reload_nginx'] = default_reload_nginx
    global account_id
    global license_key
    global output_dir
    global generate_separate_ipv4_and_ipv6_configuration_files
    global mark_tor_exit_nodes_with_T1_country_code
    global nginx_pid_file
    global database_url
    global reload_nginx
    account_id = str(config['account_id'])
    license_key = str(config['license_key'])
    database_url = str(config['database_url'])
    output_dir = Path(config['output_dir'])
    generate_separate_ipv4_and_ipv6_configuration_files = bool(config['generate_separate_ipv4_and_ipv6_configuration_files'])
    mark_tor_exit_nodes_with_T1_country_code = bool(config['mark_tor_exit_nodes_with_T1_country_code'])
    nginx_pid_file = Path(config['nginx_pid_file'])
    reload_nginx = bool(config['reload_nginx'])
# }}}

def request(method): # {{{
    timeout = ( requests_connect_timeout, requests_read_timeout )
    if account_id != '' and license_key != '':
        r = method(database_url, auth=(account_id, license_key), timeout=timeout)
    else:
        r = method(database_url, timeout=timeout)
    assert r.status_code == 200
    if 'last-modified' in r.headers:
        last_modified = r.headers['last-modified']
    else:
        last_modified = time.time()
    if 'content-disposition' in r.headers:
        content_disposition = r.headers['content-disposition']
        database_filename = content_disposition.split('=')[1]
    else: 
        database_filename = 'GeoLite2-Country-CSV.zip'
    return r, last_modified, database_filename
#}}}

def is_new_version_available(): # {{{
    r, last_modified, database_filename = request(requests.head)
    remote_version = f'{database_filename} {last_modified}'
    if 'content-length' in r.headers:
        remote_content_length = r.headers['content-length']
    else:
        remote_content_length = -1 * time.time()
    local_version = None
    local_content_length = None
    if local_database_version.is_file(): local_version = local_database_version.read_text()
    if local_database_zipfile.is_file(): local_content_length = local_database_zipfile.stat().st_size
    new_version_available = local_version != remote_version or local_content_length != remote_content_length
    return new_version_available
# }}}

def get_server_database_zipfile(): # {{{
    r, last_modified, database_filename = request(requests.get)
    version = f'{database_filename} {last_modified}'
    local_database_zipfile.write_bytes(r.content)
    local_database_version.write_text(version)
# }}}

def conditional_update_database_zipfile(): # {{{
    if is_new_version_available():
        get_server_database_zipfile()
# }}}

def extract_csv_from_zipfile(): # {{{
    found = set()
    with zipfile.ZipFile(local_database_zipfile) as zf:
        for info in zf.infolist():
            if info.is_dir():
                continue
            p = PurePosixPath(info.filename)
            if p.name in GEOLITE2_COUNTRY_TARGET_BASENAMES:
                out_path = local_database_var_dir / p.name
                with zf.open(info, "r") as src, out_path.open("wb") as dst:
                    shutil.copyfileobj(src, dst, length= 1024 * 1024 )
                found.add(p.name)
    missing = GEOLITE2_COUNTRY_TARGET_BASENAMES - found
    if missing:
        missing_files = ', '.join(sorted(missing))
        fatal(f'bad {local_database_zipfile} archive, not found files: {missing_files}')
# }}}

def ensure_expected_fieldnames(): # {{{
    error = False
    for filename, expected_fieldnames in (
                    ( blocks_ip_v4, blocks_ip_v4_fieldnames ),
                    ( blocks_ip_v6, blocks_ip_v6_fieldnames ),
                    ( locations_en, locations_en_fieldnames ),
                    ):
        with filename.open() as f:
            actual_fieldnames = f.readline().strip()
        if actual_fieldnames != expected_fieldnames:
            print(f'\nfile {filename.name} unexpected filednames:\n\n  actual: {actual_fieldnames}\n\nexpected: {expected_fieldnames}\n')
            error = True
    if error:
        sys.exit(1)
# }}}

def read_csv_files_to_memory(): # {{{

    with locations_en.open() as csv_file:
        reader = csv.DictReader(csv_file)
        for row in reader:
            geoname_id = row['geoname_id']
            assert geoname_id
            assert geoname_id not in geo_info
            geo_info[geoname_id] = row
        
    with blocks_ip_v4.open() as csv_file:
        reader = csv.DictReader(csv_file)
        for row in reader:
            network = row['network']
            assert network
            assert network not in net_ipv4
            net_ipv4[network] = row

    with blocks_ip_v6.open() as csv_file:
        reader = csv.DictReader(csv_file)
        for row in reader:
            network = row['network']
            assert network
            assert network not in net_ipv6
            net_ipv6[network] = row
# }}}

def fetch_tor_ipv4_only_exit_nodes_from_tordnsel(): # {{{
    headers = {"User-Agent": "tor-exits-now/1.3", "Accept-Encoding": "gzip"}
    timeout = (requests_connect_timeout, requests_read_timeout)
    r = requests.get(TOR_EXIT_NODES_IPV4_ONLY_URL, headers=headers, timeout=timeout)
    r.raise_for_status()
    atomic_write_text(r.text, tor_exit_nodes_ipv4_only_filename)
    out_ipv4 = set()
    for line in r.text.splitlines():
        if line.startswith("ExitAddress "):
            parts = line.split()
            if len(parts) >= 2:
                out_ipv4.add(parts[1].strip())
    return out_ipv4
# }}}

def fetch_tor_ipv4_and_ipv6_exit_nodes_from_onionoo(): # {{{
    _RE_OR_V4 = re.compile(r"^(?P<ip>(?:\d{1,3}\.){3}\d{1,3})(?::\d+(?:-\d+)?)?$")
    _RE_OR_V6 = re.compile(r"^\[(?P<ip>[0-9A-Fa-f:]+)\]:(?P<port>\d+(?:-\d+)?)$")
    def _split_or_addr(s):
        m4 = _RE_OR_V4.match(s)
        if m4:
            return "v4", m4.group("ip")
        m6 = _RE_OR_V6.match(s)
        if m6:
            return "v6", m6.group("ip").lower()
        return None, None
    headers = {"User-Agent": "tor-exits-now/1.3", "Accept-Encoding": "gzip"}
    timeout = (requests_connect_timeout, requests_read_timeout)
    params = {
        "type": "relay",
        "running": "true",
        "flag": "Exit",
        "fields": "flags,or_addresses,exit_policy_v6_summary"
    }
    r = requests.get(TOR_EXIT_NODES_IPV4_IPV6_URL, headers=headers, timeout=timeout, params=params)
    r.raise_for_status()
    data = r.json()
    atomic_write_text(json.dumps(data, indent=4), tor_exit_nodes_ipv4_ipv6_filename)
    out_ipv4 = set()
    out_ipv6 = set()
    for r in data.get("relays", []):
        flags = set(r.get("flags") or [])
        if "Exit" not in flags:
            continue
        v6sum = r.get("exit_policy_v6_summary") or {}
        if not v6sum.get("accept"):
            continue
        for addr in r.get("or_addresses") or []:
            kind, ip = _split_or_addr(addr)
            if kind == "v6":
                out_ipv6.add(ip)
            if kind == "v4":
                out_ipv4.add(ip)
    return out_ipv4, out_ipv6
# }}}

def fetch_tor_exit_nodes(): # {{{
    tor_ipv4_exit_nodes_via_method_1 = fetch_tor_ipv4_only_exit_nodes_from_tordnsel()
    tor_ipv4_exit_nodes_via_method_2, tor_ipv6_exit_nodes = fetch_tor_ipv4_and_ipv6_exit_nodes_from_onionoo()
    tor_ipv4_exit_nodes = tor_ipv4_exit_nodes_via_method_1 | tor_ipv4_exit_nodes_via_method_2
    global tor_ipv4
    global tor_ipv6
    tor_ipv4 = sorted(list(tor_ipv4_exit_nodes))
    tor_ipv6 = sorted(list(tor_ipv6_exit_nodes))
# }}}

def remove_duplicate_networks(): # {{{

    for ipv4 in tor_ipv4:
        ipv4_subnet = f'{ipv4}/32'
        if ipv4 in net_ipv4: del net_ipv4[ipv4]
        if ipv4_subnet in net_ipv4: del net_ipv4[ipv4_subnet]

    for ipv6 in tor_ipv6:
        ipv6_subnet = f'{ipv6}/128'
        if ipv6 in net_ipv6: del net_ipv6[ipv6]
        if ipv6_subnet in net_ipv6: del net_ipv6[ipv6_subnet]
# }}}

def write_include_files(): # {{{
    out_country_dict = dict()
    out_country_name = list()
    out_country_code = list()
    out_country_code.append('default XX;')
    if generate_separate_ipv4_and_ipv6_configuration_files:
        out_country_code_ipv4 = list()
        out_country_code_ipv4.append('default XX;')
        out_country_code_ipv6 = list()
        out_country_code_ipv6.append('default XX;')

    for network in net_ipv4:
        registered_country_geoname_id = net_ipv4[network]['registered_country_geoname_id']
        geoname_id = net_ipv4[network]['geoname_id']
        if not geoname_id:
            geoname_id = registered_country_geoname_id
        country_code = geo_info[geoname_id]['country_iso_code']
        continent_name = geo_info[geoname_id]['continent_name']
        country_name = geo_info[geoname_id]['country_name']
        if not country_code:
           country_code = geo_info[registered_country_geoname_id]['country_iso_code']
           continent_name = geo_info[registered_country_geoname_id]['continent_name']
           country_name = geo_info[registered_country_geoname_id]['country_name']
        assert len(country_code) == 2 and country_code.isupper()
        network_country_code = f'{network} {country_code};'
        out_country_code.append(network_country_code)
        if generate_separate_ipv4_and_ipv6_configuration_files:
            out_country_code_ipv4.append(network_country_code)
        country_description = f'"{continent_name} / {country_name}"'
        if country_code in out_country_dict:
            assert country_description == out_country_dict[country_code]
        else:
            out_country_dict[country_code] = country_description

    if mark_tor_exit_nodes_with_T1_country_code:
        for ipv4 in tor_ipv4:
            line = f'{ipv4} T1;'
            out_country_code.append(line)
            if generate_separate_ipv4_and_ipv6_configuration_files:
                out_country_code_ipv4.append(line)

    for network in net_ipv6:
        registered_country_geoname_id = net_ipv6[network]['registered_country_geoname_id']
        geoname_id = net_ipv6[network]['geoname_id']
        if not geoname_id:
            geoname_id = registered_country_geoname_id
        country_code = geo_info[geoname_id]['country_iso_code']
        continent_name = geo_info[geoname_id]['continent_name']
        country_name = geo_info[geoname_id]['country_name']
        if not country_code:
           country_code = geo_info[registered_country_geoname_id]['country_iso_code']
           continent_name = geo_info[registered_country_geoname_id]['continent_name']
           country_name = geo_info[registered_country_geoname_id]['country_name']
        assert len(country_code) == 2 and country_code.isupper()
        network_country_code = f'{network} {country_code};'
        out_country_code.append(network_country_code)
        if generate_separate_ipv4_and_ipv6_configuration_files:
            out_country_code_ipv6.append(network_country_code)
        country_description = f'"{continent_name} / {country_name}"'
        if country_code in out_country_dict:
            assert country_description == out_country_dict[country_code]
        else:
            out_country_dict[country_code] = country_description
    
    if mark_tor_exit_nodes_with_T1_country_code:
        for ipv6 in tor_ipv6:
            line = f'{ipv6} T1;'
            out_country_code.append(line)
            if generate_separate_ipv4_and_ipv6_configuration_files:
                out_country_code_ipv6.append(line)

    geoip_country_name = output_dir / 'geoip_country_name.conf'
    geoip_country_code = output_dir / 'geoip_country_code.conf'
    if generate_separate_ipv4_and_ipv6_configuration_files:
        geoip_country_code_ipv4 = output_dir / 'geoip_country_code_ipv4.conf'
        geoip_country_code_ipv6 = output_dir / 'geoip_country_code_ipv6.conf'

    assert 'XX' not in out_country_dict
    out_country_dict['XX'] = '"UNKNOWN CONTINENT / UNKNOWN COUNTRY"';
    assert 'T1' not in out_country_dict
    out_country_dict['T1'] = '"UNKNOWN CONTINENT / UNKNOWN COUNTRY / TOR NETWORK EXIT NODES"';
    for country_code in sorted(list(out_country_dict)):
        country_description = out_country_dict[country_code]
        out_country_name.append(f'{country_code} {country_description};')

    atomic_write_text( '\n'.join(out_country_name) + '\n', geoip_country_name )
    atomic_write_text( '\n'.join(out_country_code) + '\n', geoip_country_code )
    if generate_separate_ipv4_and_ipv6_configuration_files:
        atomic_write_text( '\n'.join(out_country_code_ipv4) + '\n', geoip_country_code_ipv4 )
        atomic_write_text( '\n'.join(out_country_code_ipv6) + '\n', geoip_country_code_ipv6 )
# }}}

def reload_nginx_daemon(): # {{{
    if reload_nginx:
        if nginx_pid_file.is_file():
            pid = nginx_pid_file.read_text().strip()
            try:
                os.kill(int(pid), signal.SIGHUP)
            except ProcessLookupError:
                fatal(f'reload nginx failed: process lookup error when try to send HUP signal to process with pid {pid} from nginx pid file {nginx_pid_file}')
            except PermissionError:
                fatal(f'reload nginx failed: permission denied error when try to send HUP signal to process with pid {pid} from pid file {nginx_pid_file}')
            except ValueError:
                fatal(f'reload nginx failed: unexpected pid {pid} from pid file {nginx_pid_file}')
        else:
            fatal(f'reload nginx failed: pid file {nginx_pid_file} not exists')
# }}}

def main(): # {{{
    init()
    conditional_update_database_zipfile()
    extract_csv_from_zipfile()
    ensure_expected_fieldnames()
    read_csv_files_to_memory()
    fetch_tor_exit_nodes()
    remove_duplicate_networks()
    write_include_files()
    reload_nginx_daemon()

if __name__ == '__main__':
    main() # }}}
